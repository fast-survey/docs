---
id: api-keys-vs-oauth2
title: API Keys vs. OAuth2
description: Official FastSurvey Documentation
image: /img/rocket_bg.png
---

export function Flexbox(props) {
    return (
        <div
            style={{
                width: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                marginBottom: '1.25rem',
            }}
        >
            {props.children}
        </div>
    );
}

## Types of Authentication

### `API Keys`

Using **API keys** used to be a very common way of authentication a client
with an API. Once you log in with valid credentials (e.g. email/username and
password) a random sequence of characters will be generated.

This API key has to be stored in a database and is associated with a
specific account via that database entry. It will be passed back to the
client as a response to the login-request. The client just passes this
API key along with every API request of a protected resource. Some 
significant drawbacks of using API keys:

-   There has to be an extra database/table/collection for these API keys
-   On every single request there has to be some database communication only
    for validating the API key
-   Generating a new API key generally requires the account credentials
    (e.g. email/username and password)

<br />

### `OAuth2 Tokens`

This authentication backend uses another mechanism called **OAuth 2.0**.

:::note

There are many reasons why this authentication mechanism is a good choice.
We will only cover a few advantages over using API keys but you can read the
full specification here: https://oauth.net/2/

:::

There are three benefits that we make use of:

1.  Using different types of tokens
2.  Storing the account info within the token itself
3.  Using public-key cryptography (asymmetric encryption)

<br />

## OAuth2 Implementation

### 1. Different types of credentials

**`email` and `password`** are only used to get a valid OAuth2 token which
contains the following two tokens.

The **`access_token`** (valid for 1 hour - on our backend) can be used to authenticate
requests (like an API key).

The **`refresh_token`** (valid for 2 days - on our backend) can be used to get a new
OAuth2 token containing a new valid `access_token`.

> What are the benefit of using multiple keys?

The `access_token` used for regular API requests is only valid for a short
period of time (1 hour). By using a `refresh_token`, getting a new
`access_token` does not require the user to type in email and password every
60 minutes or so.

<br />

### 2. Account info included in the token

> Why are keys _valid_ for some time period anyways?

When using API keys there is a database storing all keys that are currently
valid. With OAuth2 there is no database containing these keys.

When generating an OAuth2 token, the account information (e.g. the email
address) and an expiration date - of the token - will be encrypted with
a secret which is only known to the server. That encrypted message is the
OAuth2 Token and the additional data contained in the token is called
`payload`.

When a client passes that token along with a request the server will decrypt
the message using the secret from before and immediately knows the expiration
date as well as the account information.

No database communication necessary! The drawback is that you cannot "take
back" issued tokens but can only "wait" until they expire. To shorten that
expiration-delay, the `refresh_token` is necessary.

<br />

### 3. Asymmetric encryption

:::note

When a system provides a number of different services it might be wise to
split up the responsibilities between different servers - i.e. separation
of concerns. Further read: https://en.wikipedia.org/wiki/Microservices.

In our case we distinguish between the **authentication server** and other
**resource servers**. The authentication server is responsible for managing
account credentials (i.e. register/login functionality, etc.). However, the
resource servers should also be able to validate credentials before every
request of a restricted resource.

_This authentication-backend is the implementation of our authentication
server ;)_
:::

> And what can I do when I want to request private data from multiple servers
> with one set of credentials?

If one were to use `API keys` for that, there are two possibilities:

1. On every request a resource server has to reach out to the authentication
   server that has to tell the resource server whether the `API key` is valid
   or not
2. Every resource has to be able to read from the `API key` database

> Ahh, and with OAuth2 there is no need for a key-database but you only need
> the secret to decrypt the tokens!

Exactly. When validating OAuth2 tokens you can implement the token-decryption
on every (partly) restricted resource server. This means having the same
functionality on multiple servers but it drastically reduces the amount of
requests the authentication server has to handle.

There is still one problem when using **symmetric encryption**: The
encryption/decryption key has to be shared accross all resource servers.

The solution to that is **asymmetric encryption**. There is one **private key**
that can be used to encrypt messages. Only the authentication server knows this
key. Additionally, there is one matching **public key** - that is in fact public -
which can be used to decrypt messages.

:::note

This type of encryption is used in a variety of communication protocols.
Further read: https://en.wikipedia.org/wiki/Public-key_cryptography

:::

<br />

### Summary

The **authentication server** handles all account management. It issues
**signed tokens** and publishes its public key that can be used to decrypt
these tokens.

Every **resource server** can decrypt these **signed tokens** without any
external communication required.

```
  +--------+                                           +---------------+
  |        |--(C)--------- Login Credentials --------->| Authentication |
  |        |                                           |     Server     |
  |        |<-(D)----------- Access Token -------------|                |
  |        |                                           +---------------+
  | Client |
  |        |                                           +---------------+
  |        |--(E)----------- Access Token ------------>|    Resource    |
  |        |                                           |     Server     |
  |        |<-(F)--------- Protected Resource ---------|                |
  +--------+                                           +---------------+
```

The **`access_token`** is used to authenticate API requests on protected 
resources.

The **`refresh_token`** is used to obtain a new `access_token`.

```
  +--------+                                           +---------------+
  |        |--(A)-------- Login Credentials ---------->|                |
  |        |                                           |                |
  |        |<-(B)----------- Access Token -------------|                |
  |        |               & Refresh Token             |                |
  |        |                                           |                |
  |        |                            +----------+   |                |
  |        |--(C)---- Access Token ---->|          |   |                |
  |        |                            |          |   |                |
  |        |<-(D)- Protected Resource --| Resource |   | Authentication |
  | Client |                            |  Server  |   |     Server     |
  |        |--(E)---- Access Token ---->|          |   |                |
  |        |                            |          |   |                |
  |        |<-(F)- Invalid Token Error -|          |   |                |
  |        |                            +----------+   |                |
  |        |                                           |                |
  |        |--(G)----------- Refresh Token ----------->|                |
  |        |                                           |                |
  |        |<-(H)----------- Access Token -------------|                |
  +--------+           & Optional Refresh Token        +---------------+
```

Got the amazing charts from the official OAuth2 proposal (RFC6749, pages 6 and 10):
https://tools.ietf.org/html/rfc6749

<br />

:::note

Our resource servers fetch the public key from the authentication server
on startup. In case the authentication backend wants to update its key pair,
every resource server offers an internally used callback that triggers
fetching the new public key.

:::

:::note

By now, many digital services use OAuth2 and one major benefit is that a
service can use someone elses authentication server to authenticate users.

Some examples of these **"Authentication Providers"** are:

<Flexbox>
    <img
        src='/img/docs/authentication-01.png'
        style={{
            width: 'min(100%, 350px)',
            borderRadius: '6px',
            overflow: 'hidden',
        }}
    />
</Flexbox>

They are responsible for managing accounts and signing tokens which can be
again verified using their public key.

There are many benefits and drawbacks when using these providers. But since
we strongly focus on the protection of our users data we decided to not use
any of these providers. 

:::

<br />

## Side notes

:::note

Our implementation and this documentation both are a simplified version of
the OAuth2 proposal!

Some examples: OAuth2 distinguishes between the resource owner and the
authorization server. In addition to that, OAuth2 establishes scopes which
are different permission-levels (e.g. read-only vs. read-and-write).

You can find the **official OAuth2 proposal (RFC6749)** here:
https://oauth.net/2/, https://tools.ietf.org/html/rfc6749

:::

:::note

Distinguishing between **OAuth2** and **JWT's (JSON Web Tokens)**.

OAuth2 proposes the mechanisms mentioned above (the pretty charts) but does
not postulate any specific implemention of the encryption along with a
payload.

JWT's are one of the possible implementations of the symmetric or asymmetric 
encryption of that payload.

You can find the **official JWT proposal (RFC7519)** here:
https://jwt.io/, https://tools.ietf.org/html/rfc7519
:::

:::note

One more distinction - a quote from [Okta](https://www.okta.com/):

> **Authentication** confirms that users are who they say they are.
> **Authorization** gives those users permission to access a resource.

This backend serves both of these roles: Managing user accounts and
issuing/validating access tokens. In order not to increase confusion
we try to always use the term "authentication", even though there is
a distinction between those two terms.

:::
