---
id: introduction
title: Authentication - Introduction
sidebar_label: Introduction
description: Official FastSurvey Documentation
image: /img/rocket_bg.png
---

export function Flexbox(props) {
    return (
        <div
            style={{
                width: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                marginBottom: '1.25rem',
            }}
        >
            {props.children}
        </div>
    );
}

## Types of Authentication

### `API Keys`

Using **API keys** used to be a very common way of authentication a client
with an API. Once you log in with valid credentials (e.g. email/username and
password) a random sequence of characters will be generated.

This API key has to be stored in a database and is associated with that
specific account via the database entry. It will be passed to the client as
a response to the login-request. The client just to passes this API key
along with every API request. Some significant drawbacks of using API keys:

-   There has to be an extra database/table/collection for these API keys
-   On every single request there has to be some database communication only
    for validating the API key
-   Generating a new API key generally requires the account credentials
    (e.g. email/username and password)

<br />

### `OAuth2 Tokens`

This authentication backend uses another mechanism called **OAuth 2.0**.

:::note

There are many reasons why this authentication mechanism is a good choice.
We will only cover a few advantages over using API keys but you can read the
full specification here: https://oauth.net/2/

:::

There are three benefits that we make use of:

1.  Using Different types of credentials
2.  Storing the account info within the token itself
3.  Using public-key cryptography (asymmetric encryption)

<br />

### 1. Different types of credentials

**`email` and `password`** are only used to get a valid OAuth2 token which
contains the following two tokens.

The **`access_token`** (valid for 1 hour - on our backend) can be used to authenticate
requests (like an API key).

The **`refresh_token`** (valid for 2 days - on our backend) can be used to get a new
OAuth2 token containing a new valid `access_token`.

> What are the benefit of using multiple keys?

The `access_token` used for regular API requests is only valid for a short
period of time (1 hour). By using a `refresh_token`, getting a new
`access_token` does not require the user to type in email and password every
60 minutes or so.

<br />

### 2. Account info included in the token

> Why are keys _valid_ for some time period anyways?

When using API keys there is a database storing all keys that are currently
valid. With OAuth2 there is no database containing these keys.

When generating an OAuth2 token, the account information (e.g. the email
address) and an expiration date - of the token - will be encrypted with
a secret which is only known to the server. That encrypted message is the
OAuth2 Token and the additional data contained in the token is called
`payload`.

When a client passes that token along with a request the server will decrypt
the message using the secret from before and immediately knows the expiration
date as well as the account information.

No database communication necessary! The drawback is that you cannot "take
back" issued tokens but can only "wait" until they expire. To shorten that
expiration-delay, the `refresh_token` is necessary.

<br />

### 3. Asymmetric encryption

:::note

When a system provides a number of different services it might be wise to
split up the responsibilities between different servers - i.e. separation
of concerns. Further read: https://en.wikipedia.org/wiki/Microservices.

In our case we distinguish between the **authentication server** and other
**resource servers**. The authentication server is responsible for managing
account credentials (i.e. register/login functionality, etc.). However, the
resource servers should also be able to validate credentials before every
request of a restricted resource.

_This authentication-backend is the implementation of our authentication
server ;)_
:::

> And what can I do when I want to request private data from multiple servers
> with one set of credentials?

If one were to use `API keys` for that, there are two possibilities:

1. On every request a resource server has to reach out to the authentication
   server that has to tell the resource server whether the `API key` is valid
2. Every resource has to be able to read from the `API key` database

> Ahh, and with OAuth2 there is no need for a key-database but you only need
> the secret to decrypt the tokens!

Exactly. When validating OAuth2 tokens you can implement the token-decryption
on every (partly) restricted resource server. This means having the same
functionality on multiple servers but it drastically reduces the amount of
requests the authentication server has to handle.

There is still one problem when using **symmetric encryption**: The
encryption/decryption key has to be shared accross all resource servers.
And when that key changes, it has to happen on all servers at the exact
same moment.

The solution to that is **asymmetric encryption**. There is one **private key**
that can be used to encrypt messages. Only the authentication server knows this
key. Additionally, there is one matching **public key** - that is in fact public -
which can be used to decrypt messages.

:::note

This type of encryption is used in a variety of communication protocols.
Further read: https://en.wikipedia.org/wiki/Public-key_cryptography

:::

<br />

### Summary

The **authentication server** handles all account management. It issues
**signed tokens** and publishes its public key that can be used to decrypt
these tokens.

Every **resource server** can decrypt these **signed tokens** without any
external communication required.

:::note

Our resource servers fetch the public key from the authentication server
on startup. In case the authentication backend wants to update its key pair,
every resource server offers an internally used callback that triggers
fetching the new public key.

:::

:::note

By now, many digital services use OAuth2 and one major benefit is that a
service can use someone elses authentication server to authenticate users.

Some examples of these **"Authentication Providers"** are:

<Flexbox>
    <img
        src='/img/docs/authentication-01.png'
        style={{
            width: 'min(100%, 350px)',
            borderRadius: '6px',
            overflow: 'hidden',
        }}
    />
</Flexbox>

They also are responsible for managing accounts and signing tokens which can
be again verified using their public key.

There are many benefits and drawbacks when using these providers. But since
we strongly focus on the protection of our users data we decided to not use
any of these providers.

:::

<br />

## Encrypted Communication

It is important to make sure all communication happens over `https` and not
`http`. All `https` traffic will be encrypted by the SSL or TLS mechanisms during
transport. Two types of communication:

-   `form-data` for **Authentication Communication** (e.g. creating an account,
    logging in, etc.)

-   The 'Authorization' `header` for **Authenticated API Communication** (i.e.
    requests that enforce access reqstriction on the requested resource)

```bash
# form-data
curl 'http://localhost:3000/login' -X POST \
    -H 'Content-Type: application/json'
    -d '{"email": "...", "password": "..."}'

# header
curl 'http://localhost:3000/private-route' \
    -H 'Authorization: bearer <access_token>'
```

> Why do we only use `form-data` and `headers`?

Both **`form-data` and `headers` are encrypted by SSL/TLS**.

<br />

:::caution

`query parameters` or `path parameters` are not are encrypted by
SSL/TLS and therefore not supported.

```bash
# query parameters
curl 'http://localhost:3000/private-route?access_token=<access_token>'

# path parameters
curl 'http://localhost:3000/private-route/<access_token>'
```

:::
